[TOC]

## 阶段概览

> `Fiber`节点是如何被创建的？
>
> `Fiber Tree `是如何构建的？

`render`阶段依据本次更新是否为同步开始于 `performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`:

```javascript
function workLoopSync () {
	while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function workLoopConcurrent () {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork (unitOfWork: Fiber): void {
	const current = unitOfWork.alternate;
  
  let next;
  // ...
  next = beginWork(current, unitOfWork, subtreeRenderLanes);
	// ...
	if (next === null) {
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

`performUnitOfWork`的工作分为两个小阶段：递 和 归，分别对应着 `beginWork`方法和 `completeWork`方法。两个阶段交错执行直到`rootFiber`被处理。

![Fiber架构](../../../../images/fiber.png)



## 递 -- beginWork

从 `rootFiber`开始向下**深度优先**遍历，在每个遍历到的节点上调用 `beginWork`方法，根据传入的Fiber节点创建子Fiber节点，并连接它们；在遍历到叶子节点（即没有子组件的节点）时，转而调用`completeWork`方法。

### 方法概览

```ts
function beginWork (
	current: Fiber | null,
  workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | null {
	// ...
}
```

* `current`: 当前组件对应的 `Fiber节点` 在上一次更新时的 Fiber节点，即 `workInProgress.alternate`。
* `workInProgress`：当前组件的 `Fiber节点`。
* `renderLanes`: 优先级相关。

从 **双缓存机制**机制可知，当`mount`时，除了`rootFiber`，当前组件对应的Fiber节点不存在上一次更新的`Fiber节点`，也就是`current === null`；而`update`时，由于已经`mount`过了，`current !== null`。

由此可以将 `beginWork`的工作分为两部分：

* `mount`时，除了 `rootFiber`以外，`current === null`，根据 `fiber.tag`的不同，创建不同的`子Fiber节点`；
* `update`时，在 **满足一定条件**的情况下，复用 `current节点`。

```ts
function beginWork (
	current: Fiber | null,
  workInProgress: Fiber,
	renderLanes: Lanes
): Fiber | null {
	// update时：
	if (current !== null) {
		...
  }
	// mount时：
	switch (workInProgress.tag) {
  	...
  }
}
```

### update时

源码片段：

```ts
if (current !== null) {
	const oldProps = current.memoizedProps;
  const newProps = workInProgress.pendingProps;
  
  if (
  	oldProps !== newProps ||
		hasLegacyContextChanged() ||
    (__DEV__ ? workInProgress.type !== current.type: false)
  ) {
    didReceivedUpdate = true;
  } else if (!includesSomeLane(renderLanes, updateLanes)) {
		didReceivedUpdate = false
    switch (workInProgress.tag) {
			// 省略处理
    }
    return bailoutOnAlreadyFinishedWork(
      current,
      workInProgress,
      renderLanes,
    );
  } else {
    didReceivedUpdate = false;
  }
}
```

如上可知，当`didReceivedUpdate === false`时，复用上一次更新的 子Fiber节点，需要满足条件之一：

1. `props` 和 `fiber.type` 没发生改变；
2. `!includesSomeLane(renderLanes, updateLanes)`，即当前 Fiber节点优先级较低。

### mount时

不满足条件，则新建`子Fiber节点`。

对于`FunctionComponent/ClassComponent/HostComponent`,最终会进入`reconcileChildren`方法。



### reconcileChildren

```ts
function reconcileChildren (
	current: Fiber | null,
	workInProgress: Fiber,
	nextChildren: any,
	renderLanes: lane
) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
    	workInProgress,
      null,
      nextChildren,
      renderLanes
    );
  } else {
    workInProgress.child = reconcileChildFibers(
    	workInProgress,
      null,
      nextChildren,
      renderLanes
    );
  }
}
```

通过 `current === null` 判断是否为`mount`，但最终的逻辑是生成新的`Fiber`节点，且赋值给 `workInProgress.child`，作为本次`beginWork`的返回值，并作为下一次 `performUnitOfWork`执行时`workInProgress`的传参。



### effectTag

render阶段的工作结束后，会通知Renderer执行需要的DOM操作，具体DOM操作的类型就保存在`fiber.effectTag`中，比如：

```ts
// DOM需要插入到页面中
export const Placement = /*                */ 0b00000000000010;
// DOM需要更新
export const Update = /*                   */ 0b00000000000100;
// DOM需要插入到页面中并更新
export const PlacementAndUpdate = /*       */ 0b00000000000110;
// DOM需要删除
export const Deletion = /*                 */ 0b00000000001000;
```

具体使用时，如下：

```ts
function markUpdate(workInProgress: Fiber) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.effectTag |= Update;
}

function markRef(workInProgress: Fiber) {
  workInProgress.effectTag |= Ref;
}
```

使用二进制表示，是因为可以使得 `effectTag`能接受多个 `effect`：`if(workInProgress.effectTag & Update !== 0){ ... }`。

> 当 `workInProgress.effectTag`为 `undefined`时，`|=`操作相当于赋值。



## 归 -- completeWork

在这个阶段会调用 `completeWork`处理 Fiber 节点：当某个Fiber节点执行完`completeWork`后，如果其存在兄弟节点，那么进入兄弟节点的“递”阶段；如果不存在，则进入父节点`return fiber`的递阶段。

